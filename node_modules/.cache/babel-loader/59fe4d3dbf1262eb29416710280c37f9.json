{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nexports.getComponents = getComponents;\n\nvar _lodash = require('lodash');\n\nvar _inferComponentName = require('./utils/infer-component-name');\n\nvar _defaultNamer = require('./utils/default-namer');\n\nvar _dir = require('./utils/dir');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Let Flow know that components can have extra properties defined (eg. name\n// or .namespace)\n\n\nfunction getComponents(_ref) {\n  var fixtureFiles = _ref.fixtureFiles,\n      fixtureModules = _ref.fixtureModules;\n  var incompatFixtures = new Set();\n  var fixturesByComponent = new Map();\n  var componentNames = new Map();\n  var componentPaths = new Map();\n  fixtureFiles.forEach(function (fixtureFile) {\n    var filePath = fixtureFile.filePath;\n    var module = fixtureModules[filePath];\n\n    if (!module) {\n      console.log('[Cosmos] Missing module for ' + filePath);\n      return;\n    }\n\n    var fileName = getFileNameFromPath(filePath);\n    var fileFixtureNamer = (0, _defaultNamer.createDefaultNamer)(fileName); // Fixture files can export one fixture object or a list of fixture object\n\n    var fixturesInFile = Array.isArray(module) ? module : [module];\n    fixturesInFile.forEach(function (fixture, fixtureIndex) {\n      var component = fixture.component,\n          name = fixture.name;\n\n      if (!fixture.component) {\n        incompatFixtures.add(filePath);\n        return;\n      } // Is this the first fixture for this component?\n\n\n      var compFixtures = fixturesByComponent.get(component);\n\n      if (!compFixtures) {\n        compFixtures = [];\n        fixturesByComponent.set(component, compFixtures);\n      }\n\n      compFixtures.push({\n        filePath: filePath,\n        name: name || fileFixtureNamer(fixture.component),\n        // Note: namespace is updated later, after gathering all fixtures per\n        // component\n        namespace: '',\n        // namespace,\n        source: fixture\n      }); // Prepare for component info to be an empty list\n\n      var componentInfo = fixtureFile.components[fixtureIndex];\n\n      if (componentInfo) {\n        // Stop at the first name found. Different names for the same component\n        // can be found in future fixtures but will be ignored.\n        if (!componentNames.get(component) && componentInfo.name) {\n          componentNames.set(component, componentInfo.name);\n        } // It's possible to identify the component name but not the file path\n\n\n        if (!componentPaths.get(component) && componentInfo.filePath) {\n          componentPaths.set(component, componentInfo.filePath);\n        }\n      }\n    });\n  });\n\n  if (incompatFixtures.size > 0) {\n    var fixtureCommonDir = (0, _dir.getCommonDir)(Object.keys(fixtureModules));\n    warnAboutIncompatFixtures(incompatFixtures, fixtureCommonDir);\n  } // Add component meta data around fixtures\n\n\n  var components = [];\n  var componentPathValues = [].concat((0, _toConsumableArray3.default)(componentPaths.values()));\n  var defaultComponentNamer = (0, _defaultNamer.createDefaultNamer)('Component');\n  var componentNamers = new Map();\n\n  var _loop = function _loop(componentType) {\n    var compFixtures = fixturesByComponent.get(componentType);\n\n    if (!compFixtures) {\n      return 'continue';\n    }\n\n    var filePath = componentPaths.get(componentType) || null;\n    var namespace = typeof componentType.namespace === 'string' ? componentType.namespace : getCollapsedComponentNamespace(componentPathValues, filePath);\n    var name = // Try to read the Class/function name at run-time. User can override\n    // this for custom naming\n    (0, _inferComponentName.inferComponentName)(componentType) || // Use the name that was used to reference the component in one of its\n    // fixtures\n    componentNames.get(componentType) || // Fallback to \"Component\", \"Component (1)\", \"Component (2)\", etc.\n    defaultComponentNamer(); // Components with duplicate names can end up being squashed (#494), so\n    // it's best to keep component names unique.\n    // That said, component names only have to be unique under the same namespace\n\n    var nsName = getObjectPath({\n      name: name,\n      namespace: namespace\n    });\n    var namer = componentNamers.get(nsName);\n\n    if (!namer) {\n      namer = (0, _defaultNamer.createDefaultNamer)(name);\n      componentNamers.set(nsName, namer);\n    }\n\n    var uniqueName = namer(); // We had to wait until now to be able to determine the common dir between\n    // all fixtures belonging to the same component\n\n    var compFixtureCommonDir = (0, _dir.getCommonDir)(compFixtures.map(function (f) {\n      return f.filePath;\n    }));\n    var fixturesWithNamespace = compFixtures.map(function (f) {\n      return (0, _extends3.default)({}, f, {\n        // Check user specified namespace first, fallback to namespacing based\n        // on file path\n        namespace: f.source.namespace || getFileNamespace(compFixtureCommonDir, f.filePath)\n      });\n    });\n    components.push({\n      filePath: filePath,\n      name: uniqueName,\n      namespace: namespace,\n      type: componentType,\n      fixtures: compFixtures ? (0, _lodash.sortBy)(fixturesWithNamespace, getObjectPath) : []\n    });\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = fixturesByComponent.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var componentType = _step.value;\n\n      var _ret = _loop(componentType);\n\n      if (_ret === 'continue') continue;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return (0, _lodash.sortBy)(components, getObjectPath);\n}\n\nfunction getFileNameFromPath(filePath) {\n  return filePath.split('/').pop().split('.')[0];\n}\n\nfunction getFileNamespace(commonDir, filePath) {\n  // Warning: This function works well only when the filePath starts with /\n  return filePath ? (0, _dir.getDir)(filePath).slice(commonDir.length + 1) : '';\n}\n\nfunction getCollapsedComponentNamespace(componentPaths, filePath) {\n  var componentCommonDir = (0, _dir.getCommonDir)(componentPaths);\n  var namespace = getFileNamespace(componentCommonDir, filePath); // Nothing to collapse\n\n  if (!namespace) {\n    return namespace;\n  }\n\n  var relPath = componentCommonDir ? componentCommonDir + '/' + namespace : namespace;\n  var componentsAtPath = componentPaths.filter(function (p) {\n    return p.indexOf(relPath + '/') === 0;\n  });\n\n  if (componentsAtPath.length > 1) {\n    return namespace;\n  } // Collapse path by one level to prevent an extra nesting (eg \"Button/Button\")\n  // when there is only one component in a directory\n\n\n  return (0, _dir.getDir)(namespace);\n}\n\nfunction warnAboutIncompatFixtures(incompatFixtures, fixtureCommonDir) {\n  console.log('[Cosmos] Found ' + incompatFixtures.size + ' incompatible fixtures:');\n  console.log([].concat((0, _toConsumableArray3.default)(incompatFixtures.values())).map(function (f) {\n    return '- ' + f.slice(fixtureCommonDir.length + 1);\n  }).join('\\n'));\n  console.log('[Cosmos] Enable these fixtures by adding the `component` property.');\n  console.log('[Cosmos] More details at https://github.com/react-cosmos/react-cosmos/issues/440');\n}\n\nfunction getObjectPath(obj) {\n  return obj.namespace ? obj.namespace + '/' + obj.name : obj.name;\n}","map":null,"metadata":{},"sourceType":"script"}