{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.connectLoader = undefined;\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n/**\n * Connect fixture context (Loader) to remote Cosmos UI via configurable\n * communication channel (eg. window.postMessage or websockets)\n *\n * It both receives fixture edits from UI and forwards fixture updates bubbled\n * up from proxy chain (due to state changes) to UI.\n */\n\n\nvar connectLoader = exports.connectLoader = function () {\n  var _ref = (0, _asyncToGenerator3.default)(\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee3(args) {\n    var loadFixture = function () {\n      var _ref2 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee(fixture) {\n        var notifyParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var _createContext, mount, _splitUnserializableP, serializable;\n\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _createContext = (0, _createContext2.createContext)({\n                  renderer: renderer,\n                  proxies: proxies,\n                  fixture: fixture,\n                  onUpdate: onContextUpdate\n                }), mount = _createContext.mount;\n                _context.next = 3;\n                return mount();\n\n              case 3:\n                if (notifyParent) {\n                  // Notify back parent with the serializable contents of the loaded fixture\n                  _splitUnserializableP = (0, _reactCosmosShared.splitUnserializableParts)(fixture), serializable = _splitUnserializableP.serializable;\n                  sendMessage({\n                    type: 'fixtureLoad',\n                    fixtureBody: serializable\n                  });\n                }\n\n              case 4:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function loadFixture(_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    var onMessage = function () {\n      var _ref3 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee2(msg) {\n        var _component2, _fixture2, selectedFixture, _selected2, _component3, _fixture3;\n\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(msg.type === 'uiReady')) {\n                  _context2.next = 4;\n                  break;\n                } // This is called in the native loader, where the UI can load second\n\n\n                sendMessage({\n                  type: 'loaderReady',\n                  fixtures: extractFixtureNames(fixtures)\n                });\n                _context2.next = 27;\n                break;\n\n              case 4:\n                if (!(msg.type === 'fixtureSelect')) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                _component2 = msg.component, _fixture2 = msg.fixture;\n\n                if (!(fixtures[_component2] && fixtures[_component2][_fixture2])) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                selected = {\n                  component: _component2,\n                  fixture: _fixture2\n                }; // No need for a cache at this point. Until a fixtureUpdate or\n                // fixtureEdit event is receved, fixture source changes will be\n                // applied immediately.\n\n                fixtureCache = undefined;\n                selectedFixture = fixtures[_component2][_fixture2];\n                _context2.next = 12;\n                return loadFixture(selectedFixture);\n\n              case 12:\n                if (dismissRuntimeErrors) {\n                  dismissRuntimeErrors();\n                }\n\n                _context2.next = 16;\n                break;\n\n              case 15:\n                console.error('[Cosmos] Missing fixture for ' + String(_component2) + ':' + String(_fixture2));\n\n              case 16:\n                _context2.next = 27;\n                break;\n\n              case 18:\n                if (!(msg.type === 'fixtureEdit')) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                if (selected) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                console.error('[Cosmos] No selected fixture to edit');\n                _context2.next = 27;\n                break;\n\n              case 23:\n                // This can be the first edit after a fixture was selected\n                if (!fixtureCache) {\n                  _selected2 = selected, _component3 = _selected2.component, _fixture3 = _selected2.fixture;\n                  fixtureCache = fixtures[_component3][_fixture3];\n                } // NOTE: Edits override the entire (serializable) fixture body\n\n\n                fixtureCache = applyFixtureBody(fixtureCache, msg.fixtureBody); // Note: Creating fixture context from scratch on every fixture edit.\n                // This means that the component will always go down the\n                // componentDidMount path (instead of componentWillReceiveProps) when\n                // user edits fixture via fixture editor. In the future we might want\n                // to sometimes update the fixture context instead of resetting it.\n\n                _context2.next = 27;\n                return loadFixture(fixtureCache, false);\n\n              case 27:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function onMessage(_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    var proxies, fixtures, renderer, subscribe, unsubscribe, sendMessage, dismissRuntimeErrors, onContextUpdate, bind, unbind, isFirstCall, _selected3, _component4, _fixture4, originalFixture;\n\n    return _regenerator2.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            unbind = function unbind() {\n              unsubscribe();\n              unbindPrev = undefined;\n            };\n\n            bind = function bind() {\n              subscribe(onMessage);\n            };\n\n            onContextUpdate = function onContextUpdate(fixturePart) {\n              if (!selected) {\n                return;\n              } // This can be the first update after a fixture was selected\n\n\n              if (!fixtureCache) {\n                var _selected = selected,\n                    _component = _selected.component,\n                    _fixture = _selected.fixture;\n                fixtureCache = fixtures[_component][_fixture];\n              } // NOTE: Updates extend the fixture fields\n              // Apply the entire updated fixture part...\n\n\n              fixtureCache = applyFixturePart(fixtureCache, fixturePart); // ...but only the serializable part can be sent to parent\n\n              var _splitUnserializableP2 = (0, _reactCosmosShared.splitUnserializableParts)(fixturePart),\n                  serializable = _splitUnserializableP2.serializable;\n\n              sendMessage({\n                type: 'fixtureUpdate',\n                fixtureBody: serializable\n              });\n            };\n\n            proxies = args.proxies, fixtures = args.fixtures, renderer = args.renderer, subscribe = args.subscribe, unsubscribe = args.unsubscribe, sendMessage = args.sendMessage, dismissRuntimeErrors = args.dismissRuntimeErrors;\n            isFirstCall = !unbindPrev; // Implicitly unbind prev context when new one is created\n\n            if (unbindPrev) {\n              unbindPrev();\n            }\n\n            unbindPrev = unbind; // Always bind onMessage handler to latest input\n\n            bind();\n\n            if (!isFirstCall) {\n              _context3.next = 12;\n              break;\n            } // Let parent know loader is ready to render, along with the initial\n            // fixture list (which might update later due to HMR)\n\n\n            sendMessage({\n              type: 'loaderReady',\n              fixtures: extractFixtureNames(fixtures)\n            });\n            _context3.next = 28;\n            break;\n\n          case 12:\n            // Keep parent up to date with fixture list\n            sendMessage({\n              type: 'fixtureListUpdate',\n              fixtures: extractFixtureNames(fixtures)\n            });\n\n            if (!selected) {\n              _context3.next = 28;\n              break;\n            } // Use the fixture cache contents if present, but always re-create the\n            // context to ensure latest proxies and components are used.\n\n\n            _selected3 = selected, _component4 = _selected3.component, _fixture4 = _selected3.fixture;\n            originalFixture = fixtures[_component4][_fixture4];\n\n            if (originalFixture) {\n              _context3.next = 21;\n              break;\n            } // Maybe fixture was renamed\n\n\n            selected = undefined;\n            fixtureCache = undefined;\n            _context3.next = 28;\n            break;\n\n          case 21:\n            if (!fixtureCache) {\n              _context3.next = 26;\n              break;\n            }\n\n            _context3.next = 24;\n            return loadFixture((0, _extends3.default)({}, fixtureCache, {\n              component: originalFixture.component\n            }));\n\n          case 24:\n            _context3.next = 28;\n            break;\n\n          case 26:\n            _context3.next = 28;\n            return loadFixture(originalFixture);\n\n          case 28:\n            return _context3.abrupt('return', function destroy() {\n              if (unbindPrev) {\n                unbindPrev();\n                selected = undefined;\n                fixtureCache = undefined;\n              }\n            });\n\n          case 29:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n\n  return function connectLoader(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar _lodash = require('lodash.merge');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _reactCosmosShared = require('react-cosmos-shared');\n\nvar _createContext2 = require('./create-context');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar unbindPrev = void 0; // This will be populated on fixtureSelect events\n\nvar selected = void 0; // The fixture cache can contain\n// - Fixture updates received from proxy chain via context's onUpdate handler\n// - Fixture edits received from Playground UI\n// The cache is cleared when a fixture (including the current one) is selected\n\nvar fixtureCache = void 0;\n\nfunction extractFixtureNames(fixtures) {\n  return Object.keys(fixtures).reduce(function (acc, next) {\n    acc[next] = Object.keys(fixtures[next]);\n    return acc;\n  }, {});\n}\n\nfunction applyFixturePart(currentFixture, fixturePart) {\n  return (0, _extends3.default)({}, currentFixture, fixturePart);\n}\n\nfunction applyFixtureBody(currentFixture, fixtureBody) {\n  var _splitUnserializableP3 = (0, _reactCosmosShared.splitUnserializableParts)(currentFixture),\n      unserializable = _splitUnserializableP3.unserializable;\n\n  return (0, _lodash2.default)({}, unserializable, fixtureBody);\n}","map":null,"metadata":{},"sourceType":"script"}