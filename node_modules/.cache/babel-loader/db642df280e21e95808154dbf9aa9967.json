{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nexports.createContext = createContext;\n\nvar _asyncUntil = require('async-until');\n\nvar _asyncUntil2 = _interopRequireDefault(_asyncUntil);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactCosmosStateProxy = require('react-cosmos-state-proxy');\n\nvar _reactCosmosStateProxy2 = _interopRequireDefault(_reactCosmosStateProxy);\n\nvar _Loader = require('./components/Loader');\n\nvar _isRefSupported = require('./utils/is-ref-supported');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar wrapper = void 0;\nvar StateProxy = (0, _reactCosmosStateProxy2.default)({\n  updateInterval: 50\n});\n/**\n * Generalized way to render fixtures, without any assumptions on the renderer.\n *\n * The fixture context records state changes received from the rendered proxy\n * chain and provides helper methods for reading the latest state (via get) or\n * subscribing to all updates (via onUpdate). The former is used in headless\n * test environments while the latter in the Playground UI's \"fixture editor\".\n *\n * Important: Because some proxies are global by nature (eg. fetch-proxy mocks\n * window.fetch) there can only be one active context per page. This means that\n * mounting a new context will unmount the previous automatically.\n */\n\nfunction createContext(args) {\n  var renderer = args.renderer,\n      rendererOptions = args.rendererOptions,\n      _args$proxies = args.proxies,\n      proxies = _args$proxies === undefined ? [] : _args$proxies,\n      fixture = args.fixture,\n      onUpdate = args.onUpdate,\n      beforeInit = args.beforeInit;\n  var updatedFixture = (0, _extends3.default)({}, fixture);\n  var compRefCalled = false;\n  var compRef = void 0;\n\n  function getRef() {\n    if (!compRef) {\n      throw new Error('Component ref is not available yet. Did you mount() the context?');\n    }\n\n    return compRef;\n  }\n\n  function getWrapper() {\n    if (!wrapper) {\n      throw new Error('Context wrapper hasn\\'t been created yet. Did you mount() the context?');\n    }\n\n    return wrapper;\n  }\n\n  function get(fixtureKey) {\n    return fixtureKey ? updatedFixture[fixtureKey] : updatedFixture;\n  }\n\n  function update(fixturePart) {\n    updatedFixture = (0, _extends3.default)({}, updatedFixture, fixturePart);\n\n    if (onUpdate) {\n      onUpdate(fixturePart);\n    }\n  }\n\n  function mount() {\n    var _this = this;\n\n    var clearPrevInstance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return new Promise(function () {\n      var _ref = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee(resolve, reject) {\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n\n                if (clearPrevInstance) {\n                  unmount(); // Bring fixture to its initial state\n\n                  updatedFixture = (0, _extends3.default)({}, fixture);\n                }\n\n                wrapper = renderer(_react2.default.createElement(_Loader.Loader, {\n                  proxies: [].concat((0, _toConsumableArray3.default)(proxies), [StateProxy]),\n                  fixture: updatedFixture,\n                  onComponentRef: function onComponentRef(ref) {\n                    // Sometimes the component unmounts instantly (eg. redirects on\n                    // componentWillMount and parent HoC doesn't render it anymore).\n                    // In this cases compRef will be null but we'll know that the\n                    // component rendered\n                    compRefCalled = true;\n                    compRef = ref;\n                  },\n                  onFixtureUpdate: update\n                }), rendererOptions); // Ensure component ref is available when mounting is resolved (esp.\n                // convenient in headless tests)\n\n                if (!(0, _isRefSupported.isRefSupported)(fixture.component)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 6;\n                return (0, _asyncUntil2.default)(function () {\n                  return compRefCalled;\n                });\n\n              case 6:\n                if (!beforeInit) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 9;\n                return beforeInit();\n\n              case 9:\n                if (!fixture.init) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 12;\n                return fixture.init({\n                  compRef: compRef\n                });\n\n              case 12:\n                resolve();\n                _context.next = 18;\n                break;\n\n              case 15:\n                _context.prev = 15;\n                _context.t0 = _context['catch'](0);\n                reject(_context.t0);\n\n              case 18:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, _this, [[0, 15]]);\n      }));\n\n      return function (_x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  function unmount() {\n    if (wrapper) {\n      wrapper.unmount();\n      wrapper = undefined;\n    }\n  }\n\n  return {\n    mount: mount,\n    unmount: unmount,\n    getRef: getRef,\n    getWrapper: getWrapper,\n    get: get,\n    getField: get\n  };\n}","map":null,"metadata":{},"sourceType":"script"}