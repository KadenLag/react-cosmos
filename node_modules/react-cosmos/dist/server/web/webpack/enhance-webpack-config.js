'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _extends3 = require('babel-runtime/helpers/extends');

var _extends4 = _interopRequireDefault(_extends3);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

exports.default = enhanceWebpackConfig;

var _path = require('path');

var _lodash = require('lodash');

var _importFrom = require('import-from');

var _reactCosmosConfig = require('react-cosmos-config');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Enhance the user config to create the Loader config. Namely,
 * - Replace the entry and output
 * - Enable hot reloading
 * - Embed the user module require calls via embed-modules-webpack-loader
 * - Embed the playground options to use in the client-side bundle
 *
 * It's crucial for Cosmos to not depend on user-installed loaders. All
 * internal loaders and entries must have absolute path (via require.resolve)
 */
function enhanceWebpackConfig(_ref) {
  var webpack = _ref.webpack,
      userWebpackConfig = _ref.userWebpackConfig,
      _ref$shouldExport = _ref.shouldExport,
      shouldExport = _ref$shouldExport === undefined ? false : _ref$shouldExport;

  var cosmosConfig = (0, _reactCosmosConfig.getCosmosConfig)();
  var rootPath = cosmosConfig.rootPath,
      containerQuerySelector = cosmosConfig.containerQuerySelector,
      hot = cosmosConfig.hot,
      publicUrl = cosmosConfig.publicUrl,
      webpackOverride = cosmosConfig.webpack;


  var webpackConfig = userWebpackConfig;

  if (typeof webpackOverride === 'function') {
    console.log('[Cosmos] Overriding webpack config');
    webpackConfig = webpackOverride(webpackConfig, { env: getEnv() });
  }

  var entry = getEntry(cosmosConfig, shouldExport);
  var output = getOutput(cosmosConfig, shouldExport);

  var rules = [].concat((0, _toConsumableArray3.default)(getExistingRules(webpackConfig)), [{
    loader: require.resolve('./embed-modules-webpack-loader'),
    include: require.resolve('../../../client/user-modules')
  }]);

  var plugins = [].concat((0, _toConsumableArray3.default)(getExistingPlugins(webpackConfig)), [new webpack.DefinePlugin({
    'process.env': {
      NODE_ENV: JSON.stringify(shouldExport ? 'production' : 'development'),
      PUBLIC_URL: JSON.stringify(removeTrailingSlash(publicUrl))
    }
  }), new webpack.DefinePlugin({
    COSMOS_CONFIG: JSON.stringify({
      // Config options that are available inside the client bundle. Warning:
      // Must be serializable!
      containerQuerySelector: containerQuerySelector
    })
  }), getNoErrorsPlugin(webpack)]);

  if (!alreadyHasPlugin(webpackConfig, 'HtmlWebpackPlugin')) {
    var HtmlWebpackPlugin = (0, _importFrom.silent)(rootPath, 'html-webpack-plugin');

    if (HtmlWebpackPlugin) {
      plugins = [].concat((0, _toConsumableArray3.default)(plugins), [new HtmlWebpackPlugin({
        title: 'React Cosmos',
        filename: '_loader.html'
      })]);
    }
  }

  if (hot && !shouldExport) {
    if (!alreadyHasPlugin(webpackConfig, 'HotModuleReplacementPlugin')) {
      plugins = [].concat((0, _toConsumableArray3.default)(plugins), [new webpack.HotModuleReplacementPlugin()]);
    }
  }

  return (0, _extends4.default)({}, webpackConfig, {
    entry: entry,
    output: output,
    module: extendModuleWithRules(webpackConfig, rules),
    plugins: plugins
  });
}

function getEntry(_ref2, shouldExport) {
  var globalImports = _ref2.globalImports,
      hot = _ref2.hot;

  var entry = [].concat((0, _toConsumableArray3.default)(globalImports));

  if (hot && !shouldExport) {
    entry = [].concat((0, _toConsumableArray3.default)(entry), [require.resolve('webpack-hot-middleware/client') + '?reload=true&overlay=false']);
  }

  // Load loader entry last
  return [].concat((0, _toConsumableArray3.default)(entry), [require.resolve('../../../client/loader-entry')]);
}

function getOutput(_ref3, shouldExport) {
  var outputPath = _ref3.outputPath,
      publicUrl = _ref3.publicUrl;

  var filename = '[name].js';

  if (shouldExport) {
    return {
      path: (0, _path.join)(outputPath, publicUrl),
      filename: filename,
      publicPath: publicUrl
    };
  }

  return {
    // Setting path to `/` in development (where files are saved in memory and
    // not on disk) is a weird required for old webpack versions
    path: '/',
    filename: filename,
    publicPath: publicUrl,
    // Enable click-to-open source in react-error-overlay
    devtoolModuleFilenameTemplate: function devtoolModuleFilenameTemplate(info) {
      return (0, _path.resolve)(info.absoluteResourcePath).replace(/\\/g, '/');
    }
  };
}

function getWebpackRulesOptionName(webpackConfig) {
  // To support webpack 1 and 2 configuration formats, we use the one that
  // user passes
  return webpackConfig.module && webpackConfig.module.loaders ? 'loaders' : 'rules';
}

function getExistingRules(webpackConfig) {
  var webpackRulesOptionName = getWebpackRulesOptionName(webpackConfig);

  return webpackConfig.module && webpackConfig.module[webpackRulesOptionName] ? [].concat((0, _toConsumableArray3.default)(webpackConfig.module[webpackRulesOptionName])) : [];
}

function extendModuleWithRules(webpackConfig, rules) {
  var webpackRulesOptionName = getWebpackRulesOptionName(webpackConfig);

  return (0, _extends4.default)({}, (0, _lodash.omit)(webpackConfig.module, 'rules', 'loaders'), (0, _defineProperty3.default)({}, webpackRulesOptionName, rules));
}

function getExistingPlugins(webpackConfig) {
  var plugins = webpackConfig.plugins ? [].concat((0, _toConsumableArray3.default)(webpackConfig.plugins)) : [];

  return plugins.map(function (plugin) {
    return isPluginType(plugin, 'HtmlWebpackPlugin') ? changeHtmlPluginFilename(plugin) : plugin;
  });
}

function changeHtmlPluginFilename(htmlPlugin) {
  if (htmlPlugin.options.filename !== 'index.html') {
    return htmlPlugin;
  }

  return new htmlPlugin.constructor((0, _extends4.default)({}, htmlPlugin.options, {
    filename: '_loader.html'
  }));
}

function getNoErrorsPlugin(webpack) {
  // Important: Without this webpack tries to apply hot updates for broken
  // builds and results in duplicate React nodes attached
  // See https://github.com/webpack/webpack/issues/2117
  // Note: NoEmitOnErrorsPlugin replaced NoErrorsPlugin since webpack 2.x
  return webpack.NoEmitOnErrorsPlugin ? new webpack.NoEmitOnErrorsPlugin() : new webpack.NoErrorsPlugin();
}

function alreadyHasPlugin(_ref4, pluginName) {
  var plugins = _ref4.plugins;

  return plugins && plugins.filter(function (p) {
    return isPluginType(p, pluginName);
  }).length > 0;
}

function isPluginType(plugin, constructorName) {
  return plugin.constructor && plugin.constructor.name === constructorName;
}

function removeTrailingSlash(str) {
  return str.replace(/\/$/, '');
}

function getEnv() {
  return process.env.NODE_ENV || 'development';
}